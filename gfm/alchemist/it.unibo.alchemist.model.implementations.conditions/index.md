//[alchemist](../../index.md)/[it.unibo.alchemist.model.implementations.conditions](index.md)

# Package it.unibo.alchemist.model.implementations.conditions

[jvm]\
Conditions implementations.

## Types

| Name | Summary |
|---|---|
| [AbstractCondition](-abstract-condition/index.md) | [jvm]<br>abstract class [AbstractCondition](-abstract-condition/index.md)<[T](-abstract-condition/index.md)> : [Condition](../it.unibo.alchemist.model.interfaces/-condition/index.md)<[T](../it.unibo.alchemist.model.implementations.layers/-step-layer/index.md)> <br>concentration type |
| [AbstractNeighborCondition](-abstract-neighbor-condition/index.md) | [jvm]<br>abstract class [AbstractNeighborCondition](-abstract-neighbor-condition/index.md)<[T](-abstract-neighbor-condition/index.md)> : [AbstractCondition](-abstract-condition/index.md)<[T](-generic-molecule-present/index.md)> <br>Represents a condition on a neighbor. |
| [BiomolPresentInCell](-biomol-present-in-cell/index.md) | [jvm]<br>open class [BiomolPresentInCell](-biomol-present-in-cell/index.md) : [GenericMoleculePresent](-generic-molecule-present/index.md)<[Double](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html)> |
| [BiomolPresentInEnv](-biomol-present-in-env/index.md) | [jvm]<br>class [BiomolPresentInEnv](-biomol-present-in-env/index.md)<[P](-biomol-present-in-env/index.md) : [Position](../it.unibo.alchemist.model.interfaces/-position/index.md)<out [P](../it.unibo.alchemist.model/-biochemistry-incarnation/index.md)>?> : [GenericMoleculePresent](-generic-molecule-present/index.md)<[Double](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html)> <br>Position type |
| [BiomolPresentInNeighbor](-biomol-present-in-neighbor/index.md) | [jvm]<br>class [BiomolPresentInNeighbor](-biomol-present-in-neighbor/index.md) : [AbstractNeighborCondition](-abstract-neighbor-condition/index.md)<[Double](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html)> |
| [ComputationalRoundComplete](-computational-round-complete/index.md) | [jvm]<br>class [ComputationalRoundComplete](-computational-round-complete/index.md) : [AbstractCondition](-abstract-condition/index.md)<[Any](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)> |
| [ConcentrationChanged](-concentration-changed/index.md) | [jvm]<br>class [ConcentrationChanged](-concentration-changed/index.md)<[T](-concentration-changed/index.md)> : [AbstractCondition](-abstract-condition/index.md)<[T](../it.unibo.alchemist.model.implementations.layers/-step-layer/index.md)> <br>A condition that holds true only if the tracked [Molecule](../it.unibo.alchemist.model.interfaces/-molecule/index.md) changed its [it.unibo.alchemist.model.interfaces.Concentration](../it.unibo.alchemist.model.interfaces/-concentration/index.md). |
| [ContainsMolecule](-contains-molecule/index.md) | [jvm]<br>class [ContainsMolecule](-contains-molecule/index.md)<[T](-contains-molecule/index.md)>(**node**: [Node](../it.unibo.alchemist.model.interfaces/-node/index.md)<[T](-contains-molecule/index.md)>, **molecule**: [Molecule](../it.unibo.alchemist.model.interfaces/-molecule/index.md)) : [AbstractCondition](-abstract-condition/index.md)<[T](-contains-molecule/index.md)> <br>The condition is valid if the node contains the molecule. |
| [EnvPresent](-env-present/index.md) | [jvm]<br>class [EnvPresent](-env-present/index.md) : [AbstractCondition](-abstract-condition/index.md)<[Double](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html)> |
| [GenericMoleculePresent](-generic-molecule-present/index.md) | [jvm]<br>open class [GenericMoleculePresent](-generic-molecule-present/index.md)<[T](-generic-molecule-present/index.md) : [Number](https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html)?> : [AbstractCondition](-abstract-condition/index.md)<[T](-generic-molecule-present/index.md)> <br>This class implements a condition which checks if a molecule is present or not. |
| [GenericMoleculeUnderLevel](-generic-molecule-under-level/index.md) | [jvm]<br>class [GenericMoleculeUnderLevel](-generic-molecule-under-level/index.md)<[T](-generic-molecule-under-level/index.md) : [Number](https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html)?> : [GenericMoleculePresent](-generic-molecule-present/index.md)<[T](-generic-molecule-present/index.md)> <br>the concentration type |
| [JunctionPresentInCell](-junction-present-in-cell/index.md) | [jvm]<br>class [JunctionPresentInCell](-junction-present-in-cell/index.md) : [AbstractNeighborCondition](-abstract-neighbor-condition/index.md)<[Double](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html)> |
| [LsaAbstractCondition](-lsa-abstract-condition/index.md) | [jvm]<br>abstract class [LsaAbstractCondition](-lsa-abstract-condition/index.md) : [AbstractCondition](-abstract-condition/index.md)<[List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)<[ILsaMolecule](../it.unibo.alchemist.model.interfaces/-i-lsa-molecule/index.md)>> , [ILsaCondition](../it.unibo.alchemist.model.interfaces/-i-lsa-condition/index.md) |
| [LsaNeighborhoodCondition](-lsa-neighborhood-condition/index.md) | [jvm]<br>class [LsaNeighborhoodCondition](-lsa-neighborhood-condition/index.md) : [LsaStandardCondition](-lsa-standard-condition/index.md) |
| [LsaStandardCondition](-lsa-standard-condition/index.md) | [jvm]<br>open class [LsaStandardCondition](-lsa-standard-condition/index.md) : [LsaAbstractCondition](-lsa-abstract-condition/index.md)<br>simple LSA-condition (example: <grad,X,1>). |
| [MoleculeHasConcentration](-molecule-has-concentration/index.md) | [jvm]<br>class [MoleculeHasConcentration](-molecule-has-concentration/index.md)<[T](-molecule-has-concentration/index.md)> : [AbstractCondition](-abstract-condition/index.md)<[T](../it.unibo.alchemist.model.implementations.layers/-step-layer/index.md)> <br>A condition that is valid iff a molecule has exactly the desired concentration. |
| [NeighborhoodPresent](-neighborhood-present/index.md) | [jvm]<br>class [NeighborhoodPresent](-neighborhood-present/index.md)<[T](-neighborhood-present/index.md)> : [AbstractNeighborCondition](-abstract-neighbor-condition/index.md)<[T](-generic-molecule-present/index.md)> <br>A condition is valid if the node has a neighborhood, formally if the node has at least one node connected by a linking rule. |
| [NoOtherReactionCanExecute](-no-other-reaction-can-execute/index.md) | [jvm]<br>class [NoOtherReactionCanExecute](-no-other-reaction-can-execute/index.md)<[T](-no-other-reaction-can-execute/index.md)>(**node**: [Node](../it.unibo.alchemist.model.interfaces/-node/index.md)<[T](-no-other-reaction-can-execute/index.md)>, **myReaction**: [Reaction](../it.unibo.alchemist.model.interfaces/-reaction/index.md)<[T](-no-other-reaction-can-execute/index.md)>) : [AbstractCondition](-abstract-condition/index.md)<[T](-no-other-reaction-can-execute/index.md)> <br>The condition is valid if all the other reactions having at least one condition can not execute. |
| [TensionPresent](-tension-present/index.md) | [jvm]<br>class [TensionPresent](-tension-present/index.md) : [AbstractCondition](-abstract-condition/index.md)<[Double](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html)> |
| [WantToEscape](-want-to-escape/index.md) | [jvm]<br>open class [WantToEscape](-want-to-escape/index.md)<[T](-want-to-escape/index.md), [S](-want-to-escape/index.md) : [Vector](../it.unibo.alchemist.model.interfaces.geometry/-vector/index.md)<[S](-want-to-escape/index.md)>, [A](-want-to-escape/index.md) : [GeometricTransformation](../it.unibo.alchemist.model.interfaces.geometry/-geometric-transformation/index.md)<[S](-want-to-escape/index.md)>>(**pedestrian**: [CognitivePedestrian](../it.unibo.alchemist.model.interfaces/-cognitive-pedestrian/index.md)<[T](-want-to-escape/index.md), [S](-want-to-escape/index.md), [A](-want-to-escape/index.md)>) : [AbstractCondition](-abstract-condition/index.md)<[T](-want-to-escape/index.md)> <br>The intention of the pedestrian to evacuate or not. |
